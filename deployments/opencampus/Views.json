{
  "address": "0xB5Fe3E57C4f8C1156512d06D026C00a84edd7ceD",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_pairsBeacon",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveOut",
          "type": "uint256"
        }
      ],
      "name": "getAmountIn",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveIn",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveOut",
          "type": "uint256"
        }
      ],
      "name": "getAmountOut",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        }
      ],
      "name": "getAmountsIn",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "path",
          "type": "address[]"
        }
      ],
      "name": "getAmountsOut",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pairsBeacon",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveB",
          "type": "uint256"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountB",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "router",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "numDeployments": 10,
  "metadata": "{\"compiler\":{\"version\":\"0.8.28+commit.7893614a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pairsBeacon\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairsBeacon\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Views.sol\":\"Views\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {ContextUpgradeable} from \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\\n    struct OwnableStorage {\\n        address _owner;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Ownable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\\n\\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\\n        assembly {\\n            $.slot := OwnableStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\\n        __Ownable_init_unchained(initialOwner);\\n    }\\n\\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        return $._owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        OwnableStorage storage $ = _getOwnableStorage();\\n        address oldOwner = $._owner;\\n        $._owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xc163fcf9bb10138631a9ba5564df1fa25db9adff73bd9ee868a8ae1858fe093a\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Storage of the initializable contract.\\n     *\\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\\n     * when using with upgradeable contracts.\\n     *\\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\\n     */\\n    struct InitializableStorage {\\n        /**\\n         * @dev Indicates that the contract has been initialized.\\n         */\\n        uint64 _initialized;\\n        /**\\n         * @dev Indicates that the contract is in the process of being initialized.\\n         */\\n        bool _initializing;\\n    }\\n\\n    // keccak256(abi.encode(uint256(keccak256(\\\"openzeppelin.storage.Initializable\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\\n\\n    /**\\n     * @dev The contract is already initialized.\\n     */\\n    error InvalidInitialization();\\n\\n    /**\\n     * @dev The contract is not initializing.\\n     */\\n    error NotInitializing();\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint64 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\\n     * production.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        // Cache values to avoid duplicated sloads\\n        bool isTopLevelCall = !$._initializing;\\n        uint64 initialized = $._initialized;\\n\\n        // Allowed calls:\\n        // - initialSetup: the contract is not in the initializing state and no previous version was\\n        //                 initialized\\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\\n        //                 current contract is just being deployed\\n        bool initialSetup = initialized == 0 && isTopLevelCall;\\n        bool construction = initialized == 1 && address(this).code.length == 0;\\n\\n        if (!initialSetup && !construction) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = 1;\\n        if (isTopLevelCall) {\\n            $._initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            $._initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint64 version) {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing || $._initialized >= version) {\\n            revert InvalidInitialization();\\n        }\\n        $._initialized = version;\\n        $._initializing = true;\\n        _;\\n        $._initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        _checkInitializing();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\\n     */\\n    function _checkInitializing() internal view virtual {\\n        if (!_isInitializing()) {\\n            revert NotInitializing();\\n        }\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        // solhint-disable-next-line var-name-mixedcase\\n        InitializableStorage storage $ = _getInitializableStorage();\\n\\n        if ($._initializing) {\\n            revert InvalidInitialization();\\n        }\\n        if ($._initialized != type(uint64).max) {\\n            $._initialized = type(uint64).max;\\n            emit Initialized(type(uint64).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint64) {\\n        return _getInitializableStorage()._initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _getInitializableStorage()._initializing;\\n    }\\n\\n    /**\\n     * @dev Returns a pointer to the storage namespace.\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\\n        assembly {\\n            $.slot := INITIALIZABLE_STORAGE\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x631188737069917d2f909d29ce62c4d48611d326686ba6683e26b72a23bfac0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0xdbef5f0c787055227243a7318ef74c8a5a1108ca3a07f2b3a00ef67769e1e397\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1967.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n */\\ninterface IERC1967 {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\",\"keccak256\":\"0xb25a4f11fa80c702bf5cd85adec90e6f6f507f32f4a8e6f5dbc31e8c10029486\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x880da465c203cec76b10d72dbd87c80f387df4102274f23eea1f9c9b0918792b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/ERC1967/ERC1967Utils.sol)\\n\\npragma solidity ^0.8.21;\\n\\nimport {IBeacon} from \\\"../beacon/IBeacon.sol\\\";\\nimport {IERC1967} from \\\"../../interfaces/IERC1967.sol\\\";\\nimport {Address} from \\\"../../utils/Address.sol\\\";\\nimport {StorageSlot} from \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This library provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] slots.\\n */\\nlibrary ERC1967Utils {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev The `implementation` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidImplementation(address implementation);\\n\\n    /**\\n     * @dev The `admin` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidAdmin(address admin);\\n\\n    /**\\n     * @dev The `beacon` of the proxy is invalid.\\n     */\\n    error ERC1967InvalidBeacon(address beacon);\\n\\n    /**\\n     * @dev An upgrade function sees `msg.value > 0` that may be lost.\\n     */\\n    error ERC1967NonPayable();\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        if (newImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(newImplementation);\\n        }\\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Performs implementation upgrade with additional setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\\n        _setImplementation(newImplementation);\\n        emit IERC1967.Upgraded(newImplementation);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by ERC-1967) using\\n     * the https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the ERC-1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        if (newAdmin == address(0)) {\\n            revert ERC1967InvalidAdmin(address(0));\\n        }\\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {IERC1967-AdminChanged} event.\\n     */\\n    function changeAdmin(address newAdmin) internal {\\n        emit IERC1967.AdminChanged(getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.beacon\\\" subtracted by 1.\\n     */\\n    // solhint-disable-next-line private-vars-leading-underscore\\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the ERC-1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        if (newBeacon.code.length == 0) {\\n            revert ERC1967InvalidBeacon(newBeacon);\\n        }\\n\\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\\n\\n        address beaconImplementation = IBeacon(newBeacon).implementation();\\n        if (beaconImplementation.code.length == 0) {\\n            revert ERC1967InvalidImplementation(beaconImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Change the beacon and trigger a setup call if data is nonempty.\\n     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected\\n     * to avoid stuck value in the contract.\\n     *\\n     * Emits an {IERC1967-BeaconUpgraded} event.\\n     *\\n     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since\\n     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for\\n     * efficiency.\\n     */\\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\\n        _setBeacon(newBeacon);\\n        emit IERC1967.BeaconUpgraded(newBeacon);\\n\\n        if (data.length > 0) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        } else {\\n            _checkNonPayable();\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract\\n     * if an upgrade doesn't perform an initialization call.\\n     */\\n    function _checkNonPayable() private {\\n        if (msg.value > 0) {\\n            revert ERC1967NonPayable();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x911c3346ee26afe188f3b9dc267ef62a7ccf940aba1afa963e3922f0ca3d8a06\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback\\n     * function and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n}\\n\",\"keccak256\":\"0xc3f2ec76a3de8ed7a7007c46166f5550c72c7709e3fc7e8bb3111a7191cdedbd\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (proxy/beacon/BeaconProxy.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IBeacon} from \\\"./IBeacon.sol\\\";\\nimport {Proxy} from \\\"../Proxy.sol\\\";\\nimport {ERC1967Utils} from \\\"../ERC1967/ERC1967Utils.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\\n *\\n * The beacon address can only be set once during construction, and cannot be changed afterwards. It is stored in an\\n * immutable variable to avoid unnecessary storage reads, and also in the beacon storage slot specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[ERC-1967] so that it can be accessed externally.\\n *\\n * CAUTION: Since the beacon address can never be changed, you must ensure that you either control the beacon, or trust\\n * the beacon to not upgrade the implementation maliciously.\\n *\\n * IMPORTANT: Do not use the implementation logic to modify the beacon storage slot. Doing so would leave the proxy in\\n * an inconsistent state where the beacon storage slot does not match the beacon address.\\n */\\ncontract BeaconProxy is Proxy {\\n    // An immutable address for the beacon to avoid unnecessary SLOADs before each delegate call.\\n    address private immutable _beacon;\\n\\n    /**\\n     * @dev Initializes the proxy with `beacon`.\\n     *\\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\\n     * constructor.\\n     *\\n     * Requirements:\\n     *\\n     * - `beacon` must be a contract with the interface {IBeacon}.\\n     * - If `data` is empty, `msg.value` must be zero.\\n     */\\n    constructor(address beacon, bytes memory data) payable {\\n        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);\\n        _beacon = beacon;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address of the associated beacon.\\n     */\\n    function _implementation() internal view virtual override returns (address) {\\n        return IBeacon(_getBeacon()).implementation();\\n    }\\n\\n    /**\\n     * @dev Returns the beacon.\\n     */\\n    function _getBeacon() internal view virtual returns (address) {\\n        return _beacon;\\n    }\\n}\\n\",\"keccak256\":\"0xb719fe6bd47177169ae56e3a6300ca21cc966c649412a1d1156f02862e81beac\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {UpgradeableBeacon} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xc59a78b07b44b2cf2e8ab4175fca91e8eca1eee2df7357b8d2a8833e5ea1f64c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Errors} from \\\"./Errors.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert Errors.InsufficientBalance(address(this).balance, amount);\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason or custom error, it is bubbled\\n     * up by this function (like regular Solidity function calls). However, if\\n     * the call reverted with no returned reason, this function reverts with a\\n     * {Errors.FailedCall} error.\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert Errors.InsufficientBalance(address(this).balance, value);\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\\n     * of an unsuccessful call.\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata\\n    ) internal view returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            // only check if target is a contract if the call was successful and the return data is empty\\n            // otherwise we already know that it was a contract\\n            if (returndata.length == 0 && target.code.length == 0) {\\n                revert AddressEmptyCode(target);\\n            }\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\\n     * revert reason or with a default {Errors.FailedCall} error.\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\\n        if (!success) {\\n            _revert(returndata);\\n        } else {\\n            return returndata;\\n        }\\n    }\\n\\n    /**\\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\\n     */\\n    function _revert(bytes memory returndata) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            assembly (\\\"memory-safe\\\") {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert Errors.FailedCall();\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9d8da059267bac779a2dbbb9a26c2acf00ca83085e105d62d5d4ef96054a47f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Collection of common custom errors used in multiple contracts\\n *\\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\\n * It is recommended to avoid relying on the error API for critical functionality.\\n *\\n * _Available since v5.1._\\n */\\nlibrary Errors {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error InsufficientBalance(uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedCall();\\n\\n    /**\\n     * @dev The deployment failed.\\n     */\\n    error FailedDeployment();\\n\\n    /**\\n     * @dev A necessary precompile is missing.\\n     */\\n    error MissingPrecompile(address);\\n}\\n\",\"keccak256\":\"0x6afa713bfd42cf0f7656efa91201007ac465e42049d7de1d50753a373648c123\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC-1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(newImplementation.code.length > 0);\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * TIP: Consider using this library along with {SlotDerivation}.\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct Int256Slot {\\n        int256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\\n     */\\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        assembly (\\\"memory-safe\\\") {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97\",\"license\":\"MIT\"},\"contracts/Pair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.28;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { OwnableUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport { IPair } from \\\"./interfaces/IPair.sol\\\";\\nimport { ISwapFactory } from \\\"./interfaces/ISwapFactory.sol\\\";\\n\\nimport { Math } from \\\"./libraries/Math.sol\\\";\\nimport { UQ112x112 } from \\\"./libraries/UQ112x112.sol\\\";\\n\\nimport { PairERC20 } from \\\"./abstracts/PairERC20.sol\\\";\\n\\nimport \\\"./types.sol\\\";\\n\\ncontract Pair is IPair, PairERC20, OwnableUpgradeable {\\n\\tusing UQ112x112 for uint224;\\n\\n\\tuint public constant MINIMUM_LIQUIDITY = 10 ** 3;\\n\\tbytes4 private constant SELECTOR =\\n\\t\\tbytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n\\t/// @custom:storage-location erc7201:gainz.Pair.storage\\n\\tstruct PairStorage {\\n\\t\\taddress router;\\n\\t\\taddress token0;\\n\\t\\taddress token1;\\n\\t\\tuint112 reserve0;\\n\\t\\tuint112 reserve1;\\n\\t\\tuint32 blockTimestampLast;\\n\\t\\tuint price0CumulativeLast;\\n\\t\\tuint price1CumulativeLast;\\n\\t\\tuint kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\t\\tuint unlocked;\\n\\t}\\n\\t// keccak256(abi.encode(uint256(keccak256(\\\"gainz.Pair.storage\\\")) - 1)) & ~bytes32(uint256(0xff));\\n\\tbytes32 private constant PAIR_STORAGE_LOCATION =\\n\\t\\t0x052a7ca952fd79e6951e1e37bbd8a7a728c978d413c271dcc4d73117e8490200;\\n\\n\\tfunction _getPairStorage() private pure returns (PairStorage storage $) {\\n\\t\\tassembly {\\n\\t\\t\\t$.slot := PAIR_STORAGE_LOCATION\\n\\t\\t}\\n\\t}\\n\\n\\tmodifier lock() {\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\trequire($.unlocked == 1, \\\"Pair: LOCKED\\\");\\n\\t\\t$.unlocked = 0;\\n\\t\\t_;\\n\\t\\t$.unlocked = 1;\\n\\t}\\n\\n\\t// called once by the router at time of deployment\\n\\tfunction initialize(address _token0, address _token1) external initializer {\\n\\t\\t__Ownable_init(msg.sender);\\n\\t\\t__PairERC20_init();\\n\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\t$.router = msg.sender;\\n\\t\\t$.token0 = _token0;\\n\\t\\t$.token1 = _token1;\\n\\t\\t$.unlocked = 1;\\n\\t}\\n\\n\\t// update reserves and, on the first call per block, price accumulators\\n\\tfunction _update(\\n\\t\\tuint balance0,\\n\\t\\tuint balance1,\\n\\t\\tuint112 reserve0,\\n\\t\\tuint112 reserve1\\n\\t) private {\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\trequire(\\n\\t\\t\\tbalance0 <= type(uint112).max && balance1 <= type(uint112).max,\\n\\t\\t\\t\\\"Pair: OVERFLOW\\\"\\n\\t\\t);\\n\\n\\t\\tuint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n\\t\\tuint32 timeElapsed = blockTimestamp - $.blockTimestampLast; // Overflow is intentional here\\n\\n\\t\\tif (timeElapsed > 0 && reserve0 != 0 && reserve1 != 0) {\\n\\t\\t\\t// * never overflows, and + overflow is desired\\n\\t\\t\\t$.price0CumulativeLast +=\\n\\t\\t\\t\\tuint(UQ112x112.encode(reserve1).uqdiv(reserve0)) *\\n\\t\\t\\t\\ttimeElapsed;\\n\\t\\t\\t$.price1CumulativeLast +=\\n\\t\\t\\t\\tuint(UQ112x112.encode(reserve0).uqdiv(reserve1)) *\\n\\t\\t\\t\\ttimeElapsed;\\n\\t\\t}\\n\\n\\t\\t$.reserve0 = uint112(balance0);\\n\\t\\t$.reserve1 = uint112(balance1);\\n\\t\\t$.blockTimestampLast = blockTimestamp;\\n\\t\\temit Sync($.reserve0, $.reserve1);\\n\\t}\\n\\n\\tfunction router() external view returns (address) {\\n\\t\\treturn _getPairStorage().router;\\n\\t}\\n\\n\\tfunction token0() external view returns (address) {\\n\\t\\treturn _getPairStorage().token0;\\n\\t}\\n\\n\\tfunction token1() external view returns (address) {\\n\\t\\treturn _getPairStorage().token1;\\n\\t}\\n\\n\\tfunction getReserves()\\n\\t\\tpublic\\n\\t\\tview\\n\\t\\treturns (uint112 reserve0, uint112 reserve1, uint32 _blockTimestampLast)\\n\\t{\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\treserve0 = $.reserve0;\\n\\t\\treserve1 = $.reserve1;\\n\\t\\t_blockTimestampLast = $.blockTimestampLast;\\n\\t}\\n\\n\\tfunction _safeTransfer(address token, address to, uint value) private {\\n\\t\\t(bool success, bytes memory data) = token.call(\\n\\t\\t\\tabi.encodeWithSelector(SELECTOR, to, value)\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\\n\\t\\t\\t\\\"Pair: TRANSFER_FAILED\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction price0CumulativeLast() external view returns (uint256) {\\n\\t\\treturn _getPairStorage().price0CumulativeLast;\\n\\t}\\n\\n\\tfunction price1CumulativeLast() external view returns (uint256) {\\n\\t\\treturn _getPairStorage().price1CumulativeLast;\\n\\t}\\n\\n\\t// if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n\\tfunction _mintFee(\\n\\t\\tuint112 _reserve0,\\n\\t\\tuint112 _reserve1\\n\\t) private returns (bool feeOn) {\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\taddress feeTo = ISwapFactory($.router).feeTo();\\n\\t\\tfeeOn = feeTo != address(0);\\n\\t\\tuint _kLast = $.kLast; // gas savings\\n\\t\\tif (feeOn) {\\n\\t\\t\\tif (_kLast != 0) {\\n\\t\\t\\t\\tuint rootK = Math.sqrt(uint256(_reserve0) * uint256(_reserve1));\\n\\t\\t\\t\\tuint rootKLast = Math.sqrt(_kLast);\\n\\t\\t\\t\\tif (rootK > rootKLast) {\\n\\t\\t\\t\\t\\tuint numerator = totalSupply() * (rootK - rootKLast);\\n\\t\\t\\t\\t\\tuint denominator = (rootK * 5) + rootKLast;\\n\\t\\t\\t\\t\\tuint liquidity = numerator / denominator;\\n\\t\\t\\t\\t\\tif (liquidity > 0) _mint(feeTo, liquidity);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (_kLast != 0) {\\n\\t\\t\\t$.kLast = 0;\\n\\t\\t}\\n\\t}\\n\\n\\t// this low-level function should be called from a contract which performs important safety checks\\n\\tfunction mint(address to) external lock onlyOwner returns (uint liquidity) {\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\t(uint112 reserve0, uint112 reserve1, ) = getReserves(); // gas savings\\n\\t\\tuint balance0 = IERC20($.token0).balanceOf(address(this));\\n\\t\\tuint balance1 = IERC20($.token1).balanceOf(address(this));\\n\\t\\tuint amount0 = balance0 - reserve0;\\n\\t\\tuint amount1 = balance1 - reserve1;\\n\\n\\t\\tbool feeOn = _mintFee(reserve0, reserve1);\\n\\t\\tuint _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\\n\\t\\tif (_totalSupply == 0) {\\n\\t\\t\\tliquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\\n\\t\\t\\t_mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n\\t\\t} else {\\n\\t\\t\\tliquidity = Math.min(\\n\\t\\t\\t\\t(amount0 * _totalSupply) / reserve0,\\n\\t\\t\\t\\t(amount1 * _totalSupply) / reserve1\\n\\t\\t\\t);\\n\\t\\t}\\n\\t\\trequire(liquidity > 0, \\\"Pair: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n\\t\\t_mint(to, liquidity);\\n\\n\\t\\t_update(balance0, balance1, reserve0, reserve1);\\n\\t\\tif (feeOn) $.kLast = uint256($.reserve0) * uint256($.reserve1); // reserve0 and reserve1 are up-to-date\\n\\t\\temit Mint(msg.sender, amount0, amount1);\\n\\t}\\n\\n\\t// this low-level function should be called from a contract which performs important safety checks\\n\\tfunction burn(\\n\\t\\taddress to\\n\\t) external lock onlyOwner returns (uint amount0, uint amount1) {\\n\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\t(uint112 _reserve0, uint112 _reserve1) = ($.reserve0, $.reserve1); // gas savings\\n\\t\\taddress _token0 = $.token0; // gas savings\\n\\t\\taddress _token1 = $.token1; // gas savings\\n\\t\\tuint balance0 = IERC20(_token0).balanceOf(address(this));\\n\\t\\tuint balance1 = IERC20(_token1).balanceOf(address(this));\\n\\t\\tuint liquidity = balanceOf(address(this));\\n\\n\\t\\tbool feeOn = _mintFee(_reserve0, _reserve1);\\n\\t\\tuint _totalSupply = totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\\n\\t\\tamount0 = (liquidity * balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n\\t\\tamount1 = (liquidity * balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n\\t\\trequire(\\n\\t\\t\\tamount0 > 0 && amount1 > 0,\\n\\t\\t\\t\\\"PairV2: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n\\t\\t);\\n\\t\\t_burn(address(this), liquidity);\\n\\t\\t_safeTransfer(_token0, to, amount0);\\n\\t\\t_safeTransfer(_token1, to, amount1);\\n\\t\\tbalance0 = IERC20(_token0).balanceOf(address(this));\\n\\t\\tbalance1 = IERC20(_token1).balanceOf(address(this));\\n\\n\\t\\t_update(balance0, balance1, _reserve0, _reserve1);\\n\\t\\tif (feeOn) $.kLast = uint256($.reserve0) * uint256($.reserve1); // reserve0 and reserve1 are up-to-date\\n\\t\\temit Burn(msg.sender, amount0, amount1, to);\\n\\t}\\n\\n\\tfunction swap(\\n\\t\\tuint amount0Out,\\n\\t\\tuint amount1Out,\\n\\t\\taddress to\\n\\t) external lock onlyOwner {\\n\\t\\trequire(\\n\\t\\t\\tamount0Out > 0 || amount1Out > 0,\\n\\t\\t\\t\\\"Pair: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n\\t\\t);\\n\\t\\t(uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n\\t\\trequire(\\n\\t\\t\\tamount0Out < _reserve0 && amount1Out < _reserve1,\\n\\t\\t\\t\\\"Pair: INSUFFICIENT_LIQUIDITY\\\"\\n\\t\\t);\\n\\n\\t\\tuint balance0;\\n\\t\\tuint balance1;\\n\\t\\t{\\n\\t\\t\\tPairStorage storage $ = _getPairStorage();\\n\\n\\t\\t\\t// scope for _token{0,1}, avoids stack too deep errors\\n\\t\\t\\taddress _token0 = $.token0;\\n\\t\\t\\taddress _token1 = $.token1;\\n\\t\\t\\trequire(to != _token0 && to != _token1, \\\"Pair: INVALID_TO\\\");\\n\\t\\t\\tif (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n\\t\\t\\tif (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n\\n\\t\\t\\tbalance0 = IERC20(_token0).balanceOf(address(this));\\n\\t\\t\\tbalance1 = IERC20(_token1).balanceOf(address(this));\\n\\t\\t}\\n\\t\\tuint amount0In = balance0 > _reserve0 - amount0Out\\n\\t\\t\\t? balance0 - (_reserve0 - amount0Out)\\n\\t\\t\\t: 0;\\n\\t\\tuint amount1In = balance1 > _reserve1 - amount1Out\\n\\t\\t\\t? balance1 - (_reserve1 - amount1Out)\\n\\t\\t\\t: 0;\\n\\t\\trequire(\\n\\t\\t\\tamount0In > 0 || amount1In > 0,\\n\\t\\t\\t\\\"Pair: INSUFFICIENT_INPUT_AMOUNT\\\"\\n\\t\\t);\\n\\t\\t{\\n\\t\\t\\t// scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n\\t\\t\\tuint balance0Adjusted = (balance0 * 1000) - (amount0In * 3);\\n\\t\\t\\tuint balance1Adjusted = (balance1 * 1000) - (amount1In * 3);\\n\\t\\t\\trequire(\\n\\t\\t\\t\\t(balance0Adjusted * balance1Adjusted) >=\\n\\t\\t\\t\\t\\tuint(_reserve0) * _reserve1 * (1000 ** 2),\\n\\t\\t\\t\\t\\\"Pair: K\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t_update(balance0, balance1, _reserve0, _reserve1);\\n\\t\\temit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n\\t}\\n\\n\\tfunction skim(address to) external {}\\n\\n\\tfunction sync() external {}\\n\\n\\tfunction kLast() external view override returns (uint) {\\n\\t\\treturn _getPairStorage().kLast;\\n\\t}\\n}\\n\",\"keccak256\":\"0x6d526710d7084629c41ed98f60dcff3b253089a5711bf6e26fd5ffb8c63bee36\",\"license\":\"GPL-3.0-or-later\"},\"contracts/Views.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.28;\\nimport { AMMLibrary } from \\\"./libraries/AMMLibrary.sol\\\";\\n\\ncontract Views {\\n\\taddress public immutable router;\\n\\taddress public immutable pairsBeacon;\\n\\n\\tconstructor(address _router, address _pairsBeacon) {\\n\\t\\trouter = _router;\\n\\t\\tpairsBeacon = _pairsBeacon;\\n\\t}\\n\\n\\t// **** AMM LIBRARY FUNCTIONS ****\\n\\tfunction quote(\\n\\t\\tuint amountA,\\n\\t\\tuint reserveA,\\n\\t\\tuint reserveB\\n\\t) public pure virtual returns (uint amountB) {\\n\\t\\treturn AMMLibrary.quote(amountA, reserveA, reserveB);\\n\\t}\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint amountIn,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) public pure virtual returns (uint amountOut) {\\n\\t\\treturn AMMLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\\n\\t}\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint amountOut,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) public pure virtual returns (uint amountIn) {\\n\\t\\treturn AMMLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\\n\\t}\\n\\n\\tfunction getAmountsOut(\\n\\t\\tuint amountIn,\\n\\t\\taddress[] memory path\\n\\t) public view virtual returns (uint[] memory amounts) {\\n\\t\\treturn AMMLibrary.getAmountsOut(router, pairsBeacon, amountIn, path);\\n\\t}\\n\\n\\tfunction getAmountsIn(\\n\\t\\tuint amountOut,\\n\\t\\taddress[] memory path\\n\\t) public view virtual returns (uint[] memory amounts) {\\n\\t\\treturn AMMLibrary.getAmountsIn(router, pairsBeacon, amountOut, path);\\n\\t}\\n}\\n\",\"keccak256\":\"0xb942005fb82afae587605fed3acec302bc52a22f138cd07d20fb990eb1f65110\",\"license\":\"GPL-3.0-or-later\"},\"contracts/abstracts/PairERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.28;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport { IERC20Errors } from \\\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\\\";\\n\\nabstract contract PairERC20 is Initializable, IERC20, IERC20Errors {\\n\\tstring public constant name = \\\"GainzLP\\\";\\n\\tstring public constant symbol = \\\"GNZ-LP\\\";\\n\\tuint8 public constant decimals = 18;\\n\\n\\t/// @custom:storage-location erc7201:gainz.PairERC20.storage\\n\\tstruct PairERC20Storage {\\n\\t\\tuint totalSupply;\\n\\t\\tmapping(address => uint) balanceOf;\\n\\t\\tmapping(address => mapping(address => uint)) allowance;\\n\\t\\tbytes32 domainSeperator;\\n\\t}\\n\\t// keccak256(abi.encode(uint256(keccak256(\\\"gainz.PairERC20.storage\\\")) - 1)) & ~bytes32(uint256(0xff));\\n\\tbytes32 private constant PAIR_ERC20_STORAGE_LOCATION =\\n\\t\\t0x0053e124b05349f2255dde42e8688e7f08d28e98ecf44867b1f7ffaee445dc00;\\n\\n\\tfunction _getPairERC20Storage()\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (PairERC20Storage storage $)\\n\\t{\\n\\t\\tassembly {\\n\\t\\t\\t$.slot := PAIR_ERC20_STORAGE_LOCATION\\n\\t\\t}\\n\\t}\\n\\n\\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\\n\\t\\treturn _getPairERC20Storage().domainSeperator;\\n\\t}\\n\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\tbytes32 public constant PERMIT_TYPEHASH =\\n\\t\\t0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\tmapping(address => uint) public nonces;\\n\\n\\t// called once by the Router at time of deployment\\n\\tfunction __PairERC20_init() internal onlyInitializing {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\tuint chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid()\\n\\t\\t}\\n\\t\\t$.domainSeperator = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tkeccak256(bytes(name)),\\n\\t\\t\\t\\tkeccak256(bytes(\\\"1\\\")),\\n\\t\\t\\t\\tchainId,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _mint(address to, uint value) internal {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\t$.totalSupply += (value);\\n\\t\\t$.balanceOf[to] += (value);\\n\\t\\temit Transfer(address(0), to, value);\\n\\t}\\n\\n\\tfunction _burn(address from, uint value) internal {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\t$.balanceOf[from] -= (value);\\n\\t\\t$.totalSupply -= (value);\\n\\t\\temit Transfer(from, address(0), value);\\n\\t}\\n\\n\\tfunction _approve(address owner, address spender, uint value) private {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\t\\t$.allowance[owner][spender] = value;\\n\\t\\temit Approval(owner, spender, value);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint value) private {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\t\\t$.balanceOf[from] -= (value);\\n\\t\\t$.balanceOf[to] += (value);\\n\\t\\temit Transfer(from, to, value);\\n\\t}\\n\\n\\tfunction approve(address spender, uint value) external returns (bool) {\\n\\t\\t_approve(msg.sender, spender, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transfer(address to, uint value) external returns (bool) {\\n\\t\\t_transfer(msg.sender, to, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint value\\n\\t) external returns (bool) {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\tuint256 currentAllowance = $.allowance[from][msg.sender];\\n\\t\\tif (currentAllowance < value) {\\n\\t\\t\\trevert ERC20InsufficientAllowance(\\n\\t\\t\\t\\tmsg.sender,\\n\\t\\t\\t\\tcurrentAllowance,\\n\\t\\t\\t\\tvalue\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t$.allowance[from][msg.sender] -= (value);\\n\\n\\t\\t_transfer(from, to, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction permit(\\n\\t\\taddress owner,\\n\\t\\taddress spender,\\n\\t\\tuint value,\\n\\t\\tuint deadline,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) external {\\n\\t\\trequire(deadline >= block.timestamp, \\\"PairERC20: EXPIRED\\\");\\n\\t\\tbytes32 digest = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\\"\\\\x19\\\\x01\\\",\\n\\t\\t\\t\\tDOMAIN_SEPARATOR(),\\n\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\t\\tPERMIT_TYPEHASH,\\n\\t\\t\\t\\t\\t\\towner,\\n\\t\\t\\t\\t\\t\\tspender,\\n\\t\\t\\t\\t\\t\\tvalue,\\n\\t\\t\\t\\t\\t\\tnonces[owner]++,\\n\\t\\t\\t\\t\\t\\tdeadline\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\taddress recoveredAddress = ecrecover(digest, v, r, s);\\n\\t\\trequire(\\n\\t\\t\\trecoveredAddress != address(0) && recoveredAddress == owner,\\n\\t\\t\\t\\\"PairERC20: INVALID_SIGNATURE\\\"\\n\\t\\t);\\n\\t\\t_approve(owner, spender, value);\\n\\t}\\n\\n\\tfunction totalSupply() public view override returns (uint256) {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\treturn $.totalSupply;\\n\\t}\\n\\n\\tfunction balanceOf(address account) public view override returns (uint256) {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\treturn $.balanceOf[account];\\n\\t}\\n\\n\\tfunction allowance(\\n\\t\\taddress owner,\\n\\t\\taddress spender\\n\\t) public view virtual returns (uint256) {\\n\\t\\tPairERC20Storage storage $ = _getPairERC20Storage();\\n\\n\\t\\treturn $.allowance[owner][spender];\\n\\t}\\n}\\n\",\"keccak256\":\"0x44b5a14ed8e4e2f9da20b288be8f0bcf983a5798bc7735ad5cbb7b34bd6d183f\",\"license\":\"MIT\"},\"contracts/errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nabstract contract Errors {\\n\\terror InvalidPath(address[] path);\\n\\terror InSufficientOutputAmount(address[] path, uint256 amount);\\n}\\n\",\"keccak256\":\"0x99058f1526baf1c7f8063285799f5161a4f773d3c300b5cecedcec08ceb363ab\",\"license\":\"MIT\"},\"contracts/interfaces/IPair.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.28;\\n\\ninterface IPair {\\n\\tevent Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n\\tevent Burn(\\n\\t\\taddress indexed sender,\\n\\t\\tuint256 amount0,\\n\\t\\tuint256 amount1,\\n\\t\\taddress indexed to\\n\\t);\\n\\tevent Swap(\\n\\t\\taddress indexed sender,\\n\\t\\tuint256 amount0In,\\n\\t\\tuint256 amount1In,\\n\\t\\tuint256 amount0Out,\\n\\t\\tuint256 amount1Out,\\n\\t\\taddress indexed to\\n\\t);\\n\\tevent Sync(uint112 reserve0, uint112 reserve1);\\n\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n\\tfunction router() external view returns (address);\\n\\n\\tfunction token0() external view returns (address);\\n\\n\\tfunction token1() external view returns (address);\\n\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n\\tfunction price0CumulativeLast() external view returns (uint256);\\n\\n\\tfunction price1CumulativeLast() external view returns (uint256);\\n\\n\\tfunction kLast() external view returns (uint);\\n\\n\\tfunction mint(address to) external returns (uint256 liquidity);\\n\\n\\tfunction burn(\\n\\t\\taddress to\\n\\t) external returns (uint256 amount0, uint256 amount1);\\n\\n\\tfunction swap(uint256 amount0Out, uint256 amount1Out, address to) external;\\n\\n\\tfunction skim(address to) external;\\n\\n\\tfunction sync() external;\\n\\n\\tfunction initialize(address, address) external;\\n}\\n\",\"keccak256\":\"0x1aaa6ea3a06d7e373cbfaed81a78b943b0583c3fdfb184fc9a4352d58823c1bb\",\"license\":\"GPL-3.0-or-later\"},\"contracts/interfaces/ISwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.28;\\n\\ninterface ISwapFactory {\\n\\terror IdenticalAddress();\\n\\terror ZeroAddress();\\n\\terror PairExists();\\n\\n\\tevent PairCreated(\\n\\t\\taddress indexed token0,\\n\\t\\taddress indexed token1,\\n\\t\\taddress pair,\\n\\t\\tuint256\\n\\t);\\n\\n\\tfunction feeTo() external view returns (address);\\n\\n\\tfunction feeToSetter() external view returns (address);\\n\\n\\tfunction getPair(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) external view returns (address pair);\\n\\n\\tfunction allPairs(uint256) external view returns (address pair);\\n\\n\\tfunction allPairsLength() external view returns (uint);\\n\\n\\tfunction setFeeTo(address) external;\\n\\n\\tfunction setFeeToSetter(address) external;\\n}\\n\",\"keccak256\":\"0x8a3156561bd97ed873bebc1d8229d78fd1c6d62dcfb3d8bf64b24c274cd78948\",\"license\":\"GPL-3.0-or-later\"},\"contracts/libraries/AMMLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\nimport { BeaconProxy } from \\\"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\\\";\\n\\nimport { IPair } from \\\"../interfaces/IPair.sol\\\";\\nimport { Pair } from \\\"../Pair.sol\\\";\\n\\nimport \\\"../types.sol\\\";\\nimport \\\"../errors.sol\\\";\\n\\nlibrary AMMLibrary {\\n\\t// returns sorted token addresses, used to handle return values from pairs sorted in this order\\n\\tfunction sortTokens(\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) internal pure returns (address token0, address token1) {\\n\\t\\trequire(tokenA != tokenB, \\\"AMMLibrary: IDENTICAL_ADDRESSES\\\");\\n\\t\\t(token0, token1) = tokenA < tokenB\\n\\t\\t\\t? (tokenA, tokenB)\\n\\t\\t\\t: (tokenB, tokenA);\\n\\t\\trequire(token0 != address(0), \\\"AMMLibrary: ZERO_ADDRESS\\\");\\n\\t}\\n\\n\\t// fetches and sorts the reserves for a pair\\n\\tfunction getReserves(\\n\\t\\taddress router,\\n\\t\\taddress pairsBeacon,\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) internal view returns (uint reserveA, uint reserveB) {\\n\\t\\t(address token0, ) = sortTokens(tokenA, tokenB);\\n\\t\\t(uint reserve0, uint reserve1, ) = IPair(\\n\\t\\t\\tpairFor(router, pairsBeacon, tokenA, tokenB)\\n\\t\\t).getReserves();\\n\\t\\t(reserveA, reserveB) = tokenA == token0\\n\\t\\t\\t? (reserve0, reserve1)\\n\\t\\t\\t: (reserve1, reserve0);\\n\\t}\\n\\n\\t// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n\\tfunction quote(\\n\\t\\tuint amountA,\\n\\t\\tuint reserveA,\\n\\t\\tuint reserveB\\n\\t) external pure returns (uint amountB) {\\n\\t\\trequire(amountA > 0, \\\"AMMLibrary: INSUFFICIENT_AMOUNT\\\");\\n\\t\\trequire(\\n\\t\\t\\treserveA > 0 && reserveB > 0,\\n\\t\\t\\t\\\"AMMLibrary: INSUFFICIENT_LIQUIDITY\\\"\\n\\t\\t);\\n\\t\\tamountB = (amountA * reserveB) / reserveA;\\n\\t}\\n\\n\\t// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n\\tfunction getAmountOut(\\n\\t\\tuint amountIn,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) internal pure returns (uint amountOut) {\\n\\t\\trequire(amountIn > 0, \\\"AMMLibrary: INSUFFICIENT_INPUT_AMOUNT\\\");\\n\\t\\trequire(\\n\\t\\t\\treserveIn > 0 && reserveOut > 0,\\n\\t\\t\\t\\\"AMMLibrary: INSUFFICIENT_LIQUIDITY\\\"\\n\\t\\t);\\n\\t\\tuint amountInWithFee = amountIn * (997);\\n\\t\\tuint numerator = amountInWithFee * (reserveOut);\\n\\t\\tuint denominator = (reserveIn * 1000) + (amountInWithFee);\\n\\t\\tamountOut = numerator / denominator;\\n\\t}\\n\\n\\t// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n\\tfunction getAmountIn(\\n\\t\\tuint amountOut,\\n\\t\\tuint reserveIn,\\n\\t\\tuint reserveOut\\n\\t) internal pure returns (uint amountIn) {\\n\\t\\trequire(amountOut > 0, \\\"AMMLibrary: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n\\t\\trequire(\\n\\t\\t\\treserveIn > 0 && reserveOut > 0,\\n\\t\\t\\t\\\"AMMLibrary: INSUFFICIENT_LIQUIDITY\\\"\\n\\t\\t);\\n\\t\\tuint numerator = reserveIn * (amountOut) * (1000);\\n\\t\\tuint denominator = (reserveOut - amountOut) * (997);\\n\\t\\tamountIn = (numerator / denominator) + (1);\\n\\t}\\n\\n\\t// performs chained getAmountOut calculations on any number of pairs\\n\\tfunction getAmountsOut(\\n\\t\\taddress router,\\n\\t\\taddress pairsBeacon,\\n\\t\\tuint amountIn,\\n\\t\\taddress[] memory path\\n\\t) external view returns (uint[] memory amounts) {\\n\\t\\tif (path.length < 2) revert Errors.InvalidPath(path);\\n\\n\\t\\tamounts = new uint[](path.length);\\n\\t\\tamounts[0] = amountIn;\\n\\t\\tfor (uint i; i < path.length - 1; i++) {\\n\\t\\t\\t(uint reserveIn, uint reserveOut) = getReserves(\\n\\t\\t\\t\\trouter,\\n\\t\\t\\t\\tpairsBeacon,\\n\\t\\t\\t\\tpath[i],\\n\\t\\t\\t\\tpath[i + 1]\\n\\t\\t\\t);\\n\\t\\t\\tamounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n\\t\\t}\\n\\t}\\n\\n\\t// performs chained getAmountIn calculations on any number of pairs\\n\\tfunction getAmountsIn(\\n\\t\\taddress router,\\n\\t\\taddress pairsBeacon,\\n\\t\\tuint amountOut,\\n\\t\\taddress[] memory path\\n\\t) external view returns (uint[] memory amounts) {\\n\\t\\trequire(path.length >= 2, \\\"AMMLibrary: INVALID_PATH\\\");\\n\\t\\tamounts = new uint[](path.length);\\n\\t\\tamounts[amounts.length - 1] = amountOut;\\n\\t\\tfor (uint i = path.length - 1; i > 0; i--) {\\n\\t\\t\\t(uint reserveIn, uint reserveOut) = getReserves(\\n\\t\\t\\t\\trouter,\\n\\t\\t\\t\\tpairsBeacon,\\n\\t\\t\\t\\tpath[i - 1],\\n\\t\\t\\t\\tpath[i]\\n\\t\\t\\t);\\n\\t\\t\\tamounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction pairFor(\\n\\t\\taddress routerAddress,\\n\\t\\taddress pairsBeacon,\\n\\t\\taddress tokenA,\\n\\t\\taddress tokenB\\n\\t) internal pure returns (address pair) {\\n\\t\\t// Sort tokens to maintain consistent order\\n\\t\\t(address token0, address token1) = sortTokens(tokenA, tokenB);\\n\\n\\t\\t// Get bytecode hash for BeaconProxy with initialization parameters\\n\\t\\tbytes32 bytecodeHash = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\ttype(BeaconProxy).creationCode,\\n\\t\\t\\t\\tabi.encode(\\n\\t\\t\\t\\t\\tpairsBeacon,\\n\\t\\t\\t\\t\\tabi.encodeWithSelector(\\n\\t\\t\\t\\t\\t\\tPair.initialize.selector,\\n\\t\\t\\t\\t\\t\\ttoken0,\\n\\t\\t\\t\\t\\t\\ttoken1\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\n\\t\\tbytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n\\n\\t\\t// Compute the pair proxy address using CREATE2\\n\\t\\tpair = address(\\n\\t\\t\\tuint160(\\n\\t\\t\\t\\tuint256(\\n\\t\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\thex\\\"ff\\\",\\n\\t\\t\\t\\t\\t\\t\\trouterAddress,\\n\\t\\t\\t\\t\\t\\t\\tsalt,\\n\\t\\t\\t\\t\\t\\t\\tbytecodeHash\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0x551dbdf1c126d1eb3931291cfbc78cf92831e475f68fc54b80c807a99f1219ae\",\"license\":\"MIT\"},\"contracts/libraries/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n\\tfunction min(uint x, uint y) internal pure returns (uint z) {\\n\\t\\tz = x < y ? x : y;\\n\\t}\\n\\n\\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n\\tfunction sqrt(uint y) internal pure returns (uint z) {\\n\\t\\tif (y > 3) {\\n\\t\\t\\tz = y;\\n\\t\\t\\tuint x = y / 2 + 1;\\n\\t\\t\\twhile (x < z) {\\n\\t\\t\\t\\tz = x;\\n\\t\\t\\t\\tx = (y / x + x) / 2;\\n\\t\\t\\t}\\n\\t\\t} else if (y != 0) {\\n\\t\\t\\tz = 1;\\n\\t\\t}\\n\\t}\\n\\n\\terror MathLinearInterpolationInvalidValues(\\n\\t\\tuint256 minIn,\\n\\t\\tuint256 currentIn,\\n\\t\\tuint256 maxIn\\n\\t);\\n\\n\\t/// @dev out = (minOut * (maxIn - currentIn) + maxOut * (currentIn - minIn)) / (maxIn - minIn)\\n\\t/// \\t https://en.wikipedia.org/wiki/LinearInterpolation\\n\\tfunction linearInterpolation(\\n\\t\\tuint256 minIn,\\n\\t\\tuint256 maxIn,\\n\\t\\tuint256 currentIn,\\n\\t\\tuint256 minOut,\\n\\t\\tuint256 maxOut\\n\\t) internal pure returns (uint256) {\\n\\t\\tif (currentIn < minIn || currentIn > maxIn) {\\n\\t\\t\\trevert MathLinearInterpolationInvalidValues(\\n\\t\\t\\t\\tminIn,\\n\\t\\t\\t\\tcurrentIn,\\n\\t\\t\\t\\tmaxIn\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\tuint256 minOutWeighted = minOut * (maxIn - currentIn);\\n\\t\\tuint256 maxOutWeighted = maxOut * (currentIn - minIn);\\n\\t\\tuint256 inDiff = maxIn - minIn;\\n\\n\\t\\treturn (minOutWeighted + maxOutWeighted) / inDiff;\\n\\t}\\n}\\n\",\"keccak256\":\"0x0079a0c9124a1c1c6de9c78f790f798ddc8df61161b4747f86accdcb770e6ed3\",\"license\":\"MIT\"},\"contracts/libraries/UQ112x112.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.28;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\",\"keccak256\":\"0xa7d6bf73218a08d49ca98eb7a2c1bb3a2b4f19bd0d0795c06bec3e5eca9313a5\",\"license\":\"MIT\"},\"contracts/types.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.28;\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\nstruct LiquidityInfo {\\n\\taddress token0;\\n\\taddress token1;\\n\\tuint256 liquidity;\\n\\tuint256 liqValue;\\n\\taddress pair;\\n}\\n\\nfunction createLiquidityInfoArray(\\n\\tLiquidityInfo memory element\\n) pure returns (LiquidityInfo[] memory array) {\\n\\tarray = new LiquidityInfo[](1);\\n\\tarray[0] = element;\\n}\\n\",\"keccak256\":\"0x0e1a8c82d64dd0c82dd81c5088cf36d29268cb5dfa28673c40672a9952fccf91\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}"
}